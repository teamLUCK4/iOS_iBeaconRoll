//
//  DailyDataManager.swift
//  iOS_iBeaconRoll
//
//  Created by soo on 5/30/25.
//

import Foundation

class DailyDataManager {
    static let shared = DailyDataManager()
    
    private let cacheKey = "cachedData"
    private let dateKey = "lastFetchDate"
    private let apiURL = URL(string: "http://43.203.147.170:8080/api/students/1/schedule/today")!
    
    private init() {}
    
    func getDailyData(completion: @escaping (Result<DailySchedule, Error>) -> Void) {
        let today = formattedDate(Date())
        let lastFetched = UserDefaults.standard.string(forKey: dateKey)
        
        if lastFetched == today, let cached = UserDefaults.standard.data(forKey: cacheKey) {
            do {
                let decoder = JSONDecoder()
                decoder.dateDecodingStrategy = .custom { decoder in
                    let container = try decoder.singleValueContainer()
                    
                    // Try to decode as string first
                    if let dateString = try? container.decode(String.self) {
                        let dateFormatter = ISO8601DateFormatter()
                        dateFormatter.formatOptions = [.withInternetDateTime, .withFractionalSeconds]
                        if let date = dateFormatter.date(from: dateString) {
                            return date
                        }
                    }
                    
                    // If string decoding fails, try to decode as number (timestamp)
                    if let timestamp = try? container.decode(Double.self) {
                        return Date(timeIntervalSince1970: timestamp)
                    }
                    
                    throw DecodingError.dataCorruptedError(
                        in: container,
                        debugDescription: "Cannot decode date value"
                    )
                }
                let schedule = try decoder.decode(DailySchedule.self, from: cached)
                completion(.success(schedule))
            } catch {
                print("‚ùå [CACHE DECODING ERROR] \(error)")
                // Ï∫êÏãú ÎîîÏΩîÎî© Ïã§Ìå® Ïãú Ï∫êÏãúÎ•º ÏßÄÏö∞Í≥† APIÏóêÏÑú ÏÉàÎ°ú Í∞ÄÏ†∏Ïò§Í∏∞
                UserDefaults.standard.removeObject(forKey: cacheKey)
                UserDefaults.standard.removeObject(forKey: dateKey)
                fetchFromAPI(completion: completion)
            }
        } else {
            fetchFromAPI(completion: completion)
        }
    }
    
    private func fetchFromAPI(completion: @escaping (Result<DailySchedule, Error>) -> Void) {
        print("üåê [API REQUEST] Fetching from URL: \(apiURL)")
        
        var request = URLRequest(url: apiURL)
        request.httpMethod = "GET"
        request.setValue("application/json", forHTTPHeaderField: "Accept")
        
        URLSession.shared.dataTask(with: request) { data, response, error in
            if let error = error {
                print("‚ùå [API ERROR] \(error)")
                completion(.failure(error))
                return
            }
            
            if let httpResponse = response as? HTTPURLResponse {
                print("üì° [HTTP STATUS] \(httpResponse.statusCode)")
                if httpResponse.statusCode != 200 {
                    print("‚ùå [HTTP ERROR] Unexpected status code: \(httpResponse.statusCode)")
                    completion(.failure(NSError(domain: "HTTPError", code: httpResponse.statusCode, userInfo: [NSLocalizedDescriptionKey: "Unexpected status code: \(httpResponse.statusCode)"])))
                    return
                }
            }
            
            guard let data = data else {
                print("‚ùå [API ERROR] No data received")
                completion(.failure(NSError(domain: "DataError", code: 0, userInfo: [NSLocalizedDescriptionKey: "No data received"])))
                return
            }
            
            // Print raw JSON response
//            if let jsonString = String(data: data, encoding: .utf8) {
//                // print("üì¶ [API RAW JSON] \(jsonString)")
//            }
            
            do {
                let decoder = JSONDecoder()
                let dateFormatter = ISO8601DateFormatter()
                dateFormatter.formatOptions = [.withInternetDateTime, .withFractionalSeconds]
                
                decoder.dateDecodingStrategy = .custom { decoder in
                    let container = try decoder.singleValueContainer()
                    let dateString = try container.decode(String.self)
                    print("üìÖ [DATE PARSING] Attempting to parse date: \(dateString)")
                    
                    if let date = dateFormatter.date(from: dateString) {
                        print("‚úÖ [DATE PARSING] Successfully parsed date")
                        return date
                    }
                    
                    print("‚ùå [DATE PARSING] Failed to parse date")
                    throw DecodingError.dataCorruptedError(
                        in: container,
                        debugDescription: "Cannot decode date string \(dateString)"
                    )
                }
                
                let schedule = try decoder.decode(DailySchedule.self, from: data)
                print("‚úÖ [DECODING SUCCESS] Successfully decoded schedule")
                
                // Ï∫êÏãúÏóê Ï†ÄÏû•Ìï† ÎïåÎäî ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑÎ°ú Î≥ÄÌôò
                if let encodedData = try? JSONEncoder().encode(schedule) {
                    let json = try JSONSerialization.jsonObject(with: encodedData) as? [String: Any]
                    var modifiedJson = json ?? [:]
                    
                    // dateÏôÄ updatedAtÏùÑ ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑÎ°ú Î≥ÄÌôò
                    modifiedJson["date"] = schedule.date.timeIntervalSince1970
                    modifiedJson["updated_at"] = schedule.updatedAt.timeIntervalSince1970
                    
                    if let modifiedData = try? JSONSerialization.data(withJSONObject: modifiedJson) {
                        UserDefaults.standard.set(modifiedData, forKey: self.cacheKey)
                        UserDefaults.standard.set(self.formattedDate(Date()), forKey: self.dateKey)
                    }
                }
                
                completion(.success(schedule))
            } catch {
                print("‚ùå [DECODING ERROR] \(error)")
                if let decodingError = error as? DecodingError {
                    switch decodingError {
                    case .typeMismatch(let type, let context):
                        print("Type '\(type)' mismatch:", context.debugDescription)
                        print("codingPath:", context.codingPath)
                        if let data = try? JSONSerialization.jsonObject(with: data) as? [String: Any] {
                            print("üìÑ [JSON STRUCTURE]", data)
                        }
                    case .valueNotFound(let type, let context):
                        print("Value '\(type)' not found:", context.debugDescription)
                        print("codingPath:", context.codingPath)
                    case .keyNotFound(let key, let context):
                        print("Key '\(key)' not found:", context.debugDescription)
                        print("codingPath:", context.codingPath)
                    case .dataCorrupted(let context):
                        print("Data corrupted:", context.debugDescription)
                        print("codingPath:", context.codingPath)
                    @unknown default:
                        print("Unknown decoding error")
                    }
                }
                completion(.failure(error))
            }
        }.resume()
    }
    
    private func formattedDate(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "yyyy-MM-dd"
        return formatter.string(from: date)
    }
    
    func clearCache() {
        UserDefaults.standard.removeObject(forKey: cacheKey)
        UserDefaults.standard.removeObject(forKey: dateKey)
        print("üóëÔ∏è Cache cleared")
        
        // Fetch new data from API
        fetchFromAPI { result in
            switch result {
            case .success(let schedule):
                if let data = try? JSONEncoder().encode(schedule) {
                    UserDefaults.standard.set(data, forKey: self.cacheKey)
                    UserDefaults.standard.set(self.formattedDate(Date()), forKey: self.dateKey)
                }
            case .failure(let error):
                print("‚ùå Failed to fetch new data after cache clear: \(error)")
            }
        }
    }
    
    // MARK: - Cached Data Access
    
    /// Returns the cached DailySchedule if available, nil otherwise
    func getCachedData() -> DailySchedule? {
        guard let cached = UserDefaults.standard.data(forKey: cacheKey) else {
            return nil
        }
        
        do {
            let decoder = JSONDecoder()
            decoder.dateDecodingStrategy = .custom { decoder in
                let container = try decoder.singleValueContainer()
                
                // Try to decode as string first
                if let dateString = try? container.decode(String.self) {
                    let dateFormatter = ISO8601DateFormatter()
                    dateFormatter.formatOptions = [.withInternetDateTime, .withFractionalSeconds]
                    if let date = dateFormatter.date(from: dateString) {
                        return date
                    }
                }
                
                // If string decoding fails, try to decode as number (timestamp)
                if let timestamp = try? container.decode(Double.self) {
                    return Date(timeIntervalSince1970: timestamp)
                }
                
                throw DecodingError.dataCorruptedError(
                    in: container,
                    debugDescription: "Cannot decode date value"
                )
            }
            return try decoder.decode(DailySchedule.self, from: cached)
        } catch {
            print("‚ùå [CACHE DECODING ERROR] \(error)")
            return nil
        }
    }
    
    /// Returns true if there is valid cached data for today
    var hasValidCache: Bool {
        let today = formattedDate(Date())
        let lastFetched = UserDefaults.standard.string(forKey: dateKey)
        return lastFetched == today && UserDefaults.standard.data(forKey: cacheKey) != nil
    }
    
    // MARK: - Attendance Management
    
    /// ÌòÑÏû¨ ÏãúÍ∞ÑÏóê Ìï¥ÎãπÌïòÎäî ÏàòÏóÖÏùÑ Ï∞æÏïÑ Î∞òÌôòÌï©ÎãàÎã§.
    func getCurrentClass() -> Class? {
        guard let schedule = getCachedData() else { return nil }
        
        let now = Date()
        let calendar = Calendar.current
        
        // ÌòÑÏû¨ ÏãúÍ∞ÑÏùò Ïãú/Î∂ÑÎßå Ï∂îÏ∂ú
        let currentHour = calendar.component(.hour, from: now)
        let currentMinute = calendar.component(.minute, from: now)
        let currentTimeInMinutes = currentHour * 60 + currentMinute
        
        print("üïí ÌòÑÏû¨ ÏãúÍ∞Ñ: \(currentHour):\(currentMinute)")
        
        if let foundClass = schedule.classes.first(where: { classInfo in
            // ÏãúÏûë ÏãúÍ∞Ñ ÌååÏã±
            let startComponents = classInfo.startTime.split(separator: ":")
            guard startComponents.count == 3,
                  let startHour = Int(startComponents[0]),
                  let startMinute = Int(startComponents[1]) else {
                return false
            }
            let startTimeInMinutes = startHour * 60 + startMinute
            
            // Ï¢ÖÎ£å ÏãúÍ∞Ñ ÌååÏã±
            let endComponents = classInfo.endTime.split(separator: ":")
            guard endComponents.count == 3,
                  let endHour = Int(endComponents[0]),
                  let endMinute = Int(endComponents[1]) else {
                return false
            }
            let endTimeInMinutes = endHour * 60 + endMinute
            
            // print("üìö ÏàòÏóÖ ÏãúÍ∞Ñ: \(startHour):\(startMinute) ~ \(endHour):\(endMinute)")
            
            // ÏàòÏóÖ ÏãúÏûë 5Î∂Ñ Ï†ÑÎ∂ÄÌÑ∞ Ï¢ÖÎ£å 20Î∂Ñ ÌõÑÍπåÏßÄÎ•º ÏàòÏóÖ ÏãúÍ∞ÑÏúºÎ°ú Í∞ÑÏ£º
            let bufferTime = 5 // 5Î∂Ñ Î≤ÑÌçº
            return currentTimeInMinutes >= (startTimeInMinutes - bufferTime) &&
                   currentTimeInMinutes <= (endTimeInMinutes)
        }) {
            print("‚úÖ Ï∞æÏùÄ ÏàòÏóÖ: \(foundClass.subjectName) (\(foundClass.classroom))")
            print("üì° ÏàòÏóÖ ÎπÑÏΩò UUID: \(foundClass.beaconInfo.uuid)")
            return foundClass
        }
        
        return nil
    }
    
    /// ÌäπÏ†ï ÍµêÏã§Ïùò ÏàòÏóÖ Ï†ïÎ≥¥Î•º Ï∞æÏïÑ Î∞òÌôòÌï©ÎãàÎã§.
    func getClassForClassroom(_ classroom: String) -> Class? {
        guard let schedule = getCachedData() else { return nil }
        return schedule.classes.first { $0.classroom == classroom }
    }
    
    /// Ï∫êÏãúÎêú ÏàòÏóÖ Ï†ïÎ≥¥Î•º ÏóÖÎç∞Ïù¥Ìä∏Ìï©ÎãàÎã§.
    func updateClassStatus(classroom: String, status: AttendanceStatus) {
        guard let schedule = getCachedData() else { return }
        
        // ÏÉàÎ°úÏö¥ classes Î∞∞Ïó¥ ÏÉùÏÑ±
        var updatedClasses = schedule.classes
        if let index = updatedClasses.firstIndex(where: { $0.classroom == classroom }) {
            // ÏÉàÎ°úÏö¥ Class Í∞ùÏ≤¥ ÏÉùÏÑ±
            var updatedClass = updatedClasses[index]
            updatedClass.attendanceStatus = status
            updatedClasses[index] = updatedClass
            
            // ÏÉàÎ°úÏö¥ DailySchedule Í∞ùÏ≤¥ ÏÉùÏÑ±
            let updatedSchedule = DailySchedule(
                date: schedule.date,
                studentId: schedule.studentId,
                dayOfWeek: schedule.dayOfWeek,
                classes: updatedClasses,
                updatedAt: Date()
            )
            
            // Ï∫êÏãú ÏóÖÎç∞Ïù¥Ìä∏
            if let encodedData = try? JSONEncoder().encode(updatedSchedule) {
                UserDefaults.standard.set(encodedData, forKey: cacheKey)
            }
        }
    }
}
